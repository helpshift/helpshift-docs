---
sidebar_position: 180
title: ユーザー
description: ユーザーについて詳しく説明します
---

import {
  Admonition,
  CodeBlock,
  Tabs,
  TabItem,
  LatestSdkVersion,
  Centered,
  Image,
  Intro,
  SideBySide,
  DownloadButton,
  Steps,
  Step,
} from "@site/src/components/forDocs";

# ユーザー {#users}

<Admonition type="info" title="注意">

SDK に含まれているすべてのパブリック API は、[HelpshiftSdk.Install() API](/sdkx-unity/getting-started-android#initializing)を介して SDK を初期化した後に呼び出す必要があります

</Admonition>

## ユーザーの識別と管理 {#identify-and-manage-users}

### ユーザーのログイン {#logging-in-users}

#### 概要

ログインユーザーとは、ユーザー名とパスワードを入力した後にのみサポートチームと連絡を取ることができるユーザーのことを指しています。ログインユーザーがいる場合には、エージェントがエンドユーザーの使用デバイスにかかわらずユーザーにパーソナライズされたサポート体験を提供できるように、Login API を使用してユーザーの識別子（ユーザー ID および/またはメールアドレス）を渡すことを強くお勧めしています。また、Login API を使用することでユーザーの会話はログイン時にのみ利用可能となります。

#### 識別子として提供されるもの

ユーザーの識別には、`userID`および/または`userEmail`を提供することが可能です。弊社ではユーザー ID の使用を強く推奨しております。しかしながら、ユーザーを識別するためにメールアドレスを使用する場合には、`HelpshiftSdk.GetInstance().Login(Dictionary<string, string> data)` API 内のマップとしてそれを`userEmail`フィールドで渡す必要があります。`userID`と`userEmail`の両方を使用する場合、以下のロジックが適用されます。

<ul>
  <li>
    ユーザーを検索する際、`userId`は `userEmail`よりも優先度が高くなっています
  </li>
  <li>
    ユーザーIDが既存のユーザーに一致した場合、そのユーザーのメールアドレスは
    更新されます（メールアドレスが提供されている場合）
  </li>
  <li>
    メールアドレスが既存のユーザーに一致した場合、以下のロジックが適用されます。
    <ul>
      <li>
        メールアドレスが一致したユーザーにユーザーIDが存在しない場合、そのユーザー
        IDがそのユーザーに追加されます（ユーザーIDが提供されている場合）
      </li>
      <li>
        もしもそのユーザーIDがメールアドレスが一致しているユーザーに対して既に存在する場合、新しい
        ユーザーが作成されます（異なるユーザーIDが提供されている場合）
      </li>
    </ul>
  </li>
</ul>

#### 使用方法

ユーザーがアプリへのログインに成功するたびに、Helpshift SDK の Login API を呼び出す必要があります。Login API は、以下のパラメーターを持っています。

<table>
  <tr>
    <th>パラメーター</th>
    <th>必須/オプション</th>
    <th>SDKの説明</th>
    <th>重要事項</th>
  </tr>
  <tr>
    <td>userName</td>
    <td>オプション</td>
    <td>エージェントがエンドユーザーとやり取りをする際に使用する名前を入力します。ユーザーの名前が分からない場合には空白のままにすることができ、（有効化されている場合には）アイデンティティボットがそのユーザーに名前を尋ねます。値を指定すると、アイデンティティボットはユーザーに再度名前を尋ねなくなります。</td>
    <td>
      最大長は255文字です。これよりも長い値は切り捨てられます。
      <li>空白を取り除いた後でuserNameの値が空の文字列の場合、このパラメーターは「login」呼び出しに含まれなくなります。 </li>
    </td>
  </tr>
  <tr>
    <td>userId</td>
    <td>メールアドレスが提供されていない場合には必須の識別子となります</td>
    <td>ユーザー固有の識別子です。ユーザーIDは一意である必要があります。異なるユーザーに同一のユーザーIDを使用させるべきではありません。</td>
    <td>
      <ul>
        <li>最大長は750文字です。これよりも長い値を許可すると、結果的に匿名ユーザーが作成されてしまいます。</li>
        <li>先頭および末尾のスペースは許可されません。中間にスペースを入れることは可能です。先頭および末尾にスペースが含まれているユーザーIDを許可すると、結果的に匿名ユーザーが作成されてしまいます。</li>
        <li>ユーザーIDは常に大文字と小文字を区別します（たとえば、1abcと1ABCは別のIDとなります）。</li>
        <li>ユーザーのメールアドレスを'userID'として使用しないでください。ユーザーの識別にメールアドレスを利用する場合には、'userEmail'として使用してください。</li>
        <li>メールアドレスだけでなくユーザーIDも使用する場合には、その後の呼び出しでユーザーIDが存在することを確認してください。複数のプロファイルが同じメールアドレスを使用している場合、メールアドレスを使用するだけではすべてのプロファイルが返されてしまいます。</li>
        <li> "userId"の値が空白を取り除いた後の空の文字列である場合、このパラメーターを"login"呼び出しに含めないでください。 </li>
      </ul>
</td>
  </tr>
  <tr>
    <td>userEmail</td>
    <td>ユーザーIDが提供されていない場合には必須の識別子となります</td>
    <td>ユーザーのメールアドレスです。ユーザーのメールアドレスが分からない場合には空白のままにすることができ、（有効化されている場合には）アイデンティティボットがそのユーザーにメールアドレスを尋ねます。値を指定すると、アイデンティティボットはユーザーに再度メールアドレスを尋ねなくなります。</td>
    <td>
      <ul>
        <li>メールアドレスの形式は、有効なものである必要があります（"my@email.com"の形式を使用する必要があります）無効なメールアドレスを許可すると、結果的に匿名ユーザーが作成されてしまいます。</li>
        <li>先頭および末尾のスペースは許可されません。先頭および末尾にスペースが含まれているメールアドレスを許可すると、結果的に匿名ユーザーが作成されてしまいます。</li>
        <li>メールアドレスでは、大文字と小文字は常に区別されません（たとえば、MY@EMAIL.COMとmy@email.comは同じメールアドレスです）。</li></ul>/n</td>
        <li> "userEmail"の値が空白を取り除いた後の空の文字列である場合、このパラメーターを"login"呼び出しに含めないでください。 </li>
  </tr>
  <tr>
    <td>userAuthToken</td>
    <td>オプション</td>
    <td>SHA256を使用したハッシュベースのメッセージ認証コード（HMAC）を介して生成されたユーザー認証トークンです。第三者がユーザーに代わって問題を提出したり、ユーザーのプロパティを更新したりできないようにする場合には、HMACダイジェストを使用する必要があります。 詳細は<a href="https://support.helpshift.com/kb/article/what-is-user-identity-verification-and-how-do-i-set-it-up/">こちら</a>。</td>
    <td>
      <ul>
        <li>ユーザーが確実に問題を提出できるようにするために、有効なHMACダイジェストを使用する必要があります。詳細は<a href="https://support.helpshift.com/kb/article/how-do-i-test-that-i-have-user-identity-verification-set-up-correctly/">こちら</a>。</li>
        <li> "userAuthToken"の値が空白を取り除いた後の空の文字列である場合、このパラメーターを"login"呼び出しに含めないでください。 </li>
      </ul>
</td>

  </tr>
</table>

`HelpshiftSdk.Login()` API を使用する際は、以下の点に注意する必要があります。-

- Helpshift でログインユーザーを作成するには、`userId`または`userEmail`のいずれかを使用する必要があります。
- `userId`または`userEmail`は、すべてのアプリユーザーの間でユーザーを一意に識別する必要があります。2 人以上の異なるユーザーが重複して使用するべきでは**ありません**。
- Login API が異なるユーザー識別子を用いて呼び出された場合には、最初に現在のログインユーザーをログアウトし、次にこのユーザー識別子を用いてログインを行います。
- アプリのユーザーがログインしたら、すぐに login 呼び出しを行うのがベストです。
- `fullPrivacy`を true に設定している場合、そのユーザーの Login API でメールアドレスを唯一の識別子として使うべきではありません。これを行うと、結果的に匿名ユーザーが作成されてしまいます。

<Admonition type="info" title="注意">

10.3.0 以降では、`HelpshiftSdk.Login()` API はログインが成功したかどうかを示すブーリアン値を返します。この変更は既存の API にログインパラメーターに対する強制的な検証を導入するためのものであるため、コードのコンパイルに影響を与える可能性があります。

</Admonition>

```csharp
using Helpshift;
// ..

 HelpshiftSdk _support = HelpshiftSdk.GetInstance();

 void Awake(){
  // install call here
 }

 void Login() {
  Dictionary<string, string> userDetails = new Dictionary<string, string>();

  string userId = generateUserId();
  string userEmail = fetchUserEmail();
  string userName = fetchUserName();

  if (strings.IsNullOrEmpty(userId) && strings.IsNullOrEmpty(userEmail)) {
    throw new Exception("userId and userEmail both are empty. Invalid login! ");
  }

  if (!strings.IsNullOrEmpty(userId)) {
    userDetails["userId"] = userId;
  }

  if (!strings.IsNullOrEmpty(userEmail)) {
    userDetails["userEmail"] = userEmail;
  }

  if (!strings.IsNullOrEmpty(userName)) {
    userDetails["userName"] = userName;
  }

  bool loginSuccess = _support.Login(userDetails);
  Debug.Log("Helpshift - loginSucccess : " + loginSuccess);
 }
```

### ユーザーのログアウト {#logging-out-users}

#### 概要

ユーザーがアプリからログアウトしたら、Helpshift SDK の Logout API を呼び出し、他のユーザーがこのユーザーの会話を表示できないようにする必要があります。

<Admonition type="info" title="注意">

Logout API は、Login API と組み合わせて使用することが期待されています。

</Admonition>

#### 使用方法

```csharp
_support.Logout();
```

### 匿名ユーザー {#anonymous-users}

#### 概要

匿名ユーザーとは、ユーザー名とパスワードなしでアプリにアクセスできるユーザーのことを指します。Login API 経由でユーザー識別子（ユーザー ID および/またはメールアドレス）が渡されていない場合、Helpshift はそのユーザーが匿名ユーザーであり、現在ログインしていないものとみなします。

複数のログインユーザー/匿名ユーザーが同じデバイスを使用してサポート会話中に情報のやり取りを行う（理想としてはログインをまたいだ共有を許可したくないない）ユースケースの場合には、`_support.ClearAnonymousUserOnLogin(shouldClear)`機能を使用する必要があります。

- shouldClear が`true`の場合 – 匿名ユーザーは、どのユーザーがログインしても消去されます。一度消去されると、そういったユーザー（およびその会話）は二度と取得できなくなります。

- shouldClear が`false`の場合 – 匿名ユーザーのデータは保存され、ログインユーザーがログアウトすると、匿名ユーザーの会話履歴が表示されます。

```csharp
help = HelpshiftSdk.GetInstance();
help.ClearAnonymousUserOnLogin(shouldClear);
```

<Admonition type="info" title="注意">

ClearAnonymousUserOnLogin()機能は、ログインユーザーのエクスペリエンスには一切影響を与えません

</Admonition>

## ユーザーの同一性の確認 {#identify-users}

### アプリ内で同一性の確認を構成する

#### 概要

ユーザーの同一性の確認は、お客様のアプリから Helpshift へのすべてのリクエストが正当なエンドユーザーからのものであることを確認するためのセキュリティ施策です。これにより、第三者やハッカーによるユーザーのなりすましを防止することができます。ユーザーの同一性の確認に関する詳細情報と設定の手順については、[こちら](https://support.helpshift.com/kb/article/what-is-user-identity-verification-and-how-do-i-set-it-up/)をご参照ください。ユーザーを確実に認証するためには、初期化の際に`_support.Login(Dictionary<string, string> userData)`とともにユーザー認証トークンを提供する必要があります。ユーザー認証トークンの生成手順については、[こちら](https://support.helpshift.com/kb/article/how-do-i-configure-the-endpoint-and-my-app-web-chat-widget-for-user-identity-verification/)をご参照ください。ユーザー認証トークンは HMAC ダイジェストであり、SHA256 を使用した HMAC を介して生成されます。

#### HMAC ダイジェストを送信してユーザーの同一性を確認する

Login API 呼び出しでユーザー認証トークンを送信することができます。 Helpshift ダッシュボード（ドキュメントは[こちら](https://support.helpshift.com/kb/article/what-is-user-identity-verification-and-how-do-i-set-it-up/)）で本人確認が有効になっている場合、Helpshift は共有秘密鍵を使用して固有のユーザー認証トークンを再計算し、お客様から送信されたユーザー認証トークンと再計算された値を比較します。それらが一致していればユーザーの同一性が確認されたことになり、ユーザーは問題を提出することができます。

```csharp
using Helpshift;
// ..

 HelpshiftSdk _support = HelpshiftSdk.GetInstance();

 void Awake(){
  // install call here
 }

 void Login(){
  Dictionary<string, string> userDetails = new Dictionary<string, string>();

  string userId = generateUserId();
  string userEmail = fetchUserEmail();
  string userName = fetchUserName();

  if (strings.IsNullOrEmpty(userId) && strings.IsNullOrEmpty(userEmail)) {
    throw new Exception("userId and userEmail both are empty. Invalid login! ");
  }

  if (!strings.IsNullOrEmpty(userId)) {
    userDetails["userId"] = userId;
  }

  if (!strings.IsNullOrEmpty(userEmail)) {
    userDetails["userEmail"] = userEmail;
  }

  if (!strings.IsNullOrEmpty(userName)) {
    userDetails["userName"] = userName;
  }

  string userAuthToken = generateUserAuthToken();

  if (!strings.IsNullOrEmpty(userAuthToken)) {
    userDetails["userAuthToken"] = userAuthToken;
  }

  bool loginSuccess = _support.Login(userDetails);
  Debug.Log("Helpshift - loginSucccess : " + loginSuccess);
 }
```

<Admonition type="info" title="注意">

- ダッシュボードでアプリの秘密鍵が再生成された場合、有効なユーザー認証トークンを生成するために、エンドポイントのコードも確実に更新する必要があります。続いて、古い秘密鍵を使用して生成されたユーザー認証トークンを使用したリクエストが無効になるように、管理者はダッシュボードから古い秘密鍵を削除する必要があります。

- EnableFullPrivacy がオンになっている場合には、ユーザー認証トークンはユーザー ID に対してのみ生成されます。

</Admonition>

### 本人確認の失敗 {#identity-verification-failure}

#### 概要

本人確認がオンになっている場合、ユーザー認証トークンがない、もしくは無効なユーザー認証トークンを用いた状態でログインリクエストが行われると、本人確認が失敗となります。本人確認に失敗すると、以下のようになります。

- 匿名ユーザー（開発者が識別子を提供していないユーザー）は、常に問題を提出することができます。
- ログインユーザー（開発者がユーザー ID やメールアドレスなどの識別子を提供しているユーザー）は、認証されていない場合には問題を提出したり会話を確認したりすることができません。未認証のログインユーザーに対しては、フォームまたは対話型 UI でエラーが表示されます。

ログインユーザーが認証されると（つまり、有効なユーザー認証トークンが提供されると）、前回の問題を確認したり、新しい課題を作成したりすることができるようになります。認証が完了したログインユーザーの UI は本人確認がオフになっている場合とまったく同じように表示され、動作します。上記のような影響を受けるのは、認証が完了していないユーザーのみです。

#### 失敗デリゲートの使用方法

本人確認に失敗した場合、SDK は`AuthenticationFailedForUser(...)`デリゲートを呼び出し、アプリケーションに失敗を通知します。

<table>
  <tr>
    <th>認証失敗の理由</th>
    <th>呼び出されるタイミング</th>
    <th>使用するタイミング</th>
  </tr>
  <tr>
    <td>
      HelpshiftAuthenticationFailureReason <br />
      .AUTH_TOKEN_NOT_PROVIDED
    </td>
    <td>ユーザー認証トークンが提供されなかったとき</td>
    <td>
      ユーザー認証トークンを送信する予定はないものの将来的に実装する予定がある
      場合には、この失敗デリゲートを使用してアプリのアップデートを促すような独自のアラートを
      ユーザーに対して表示することができます。ユーザー認証トークンを使用せずに
      Login
      APIを使用している場合には、ダッシュボードで本人確認を有効にするとこれらの
      ユーザーは未認証であるとみなされてしまうため、これを使用すると良いかもしれません。
      このデリゲートの使用については、完全に任意となっております。前述の通り、
      Helpshiftでは未認証のユーザー が問題を提出することはできません。
    </td>
  </tr>
  <tr>
    <td>
      HelpshiftAuthenticationFailureReason <br />
      .INVALID_AUTH_TOKEN
    </td>
    <td>ユーザー認証トークンが無効だったとき</td>
    <td>
      Login APIを介して提供されるHMACダイジェストが無効な場合、Helpshift
      はユーザーによる問題の提出を阻止します。以下の場合、ユーザー認証トークン
      が無効である可能性があります。
      <ul>
        <li>
          プログラミングにミスがある場合。HMACダイジェストの生成方法については、{" "}
          <a href="https://support.helpshift.com/kb/article/how-do-i-configure-the-endpoint-and-my-app-web-chat-widget-for-user-identity-verification/">
            こちら
          </a>
          をご参照ください。
        </li>
        <li>
          ダッシュボードで秘密鍵を再生成したものの、
          ユーザー認証トークンを更新していなかった場合。
        </li>
        <li>第三者がリクエストを試みている場合。</li>
      </ul>
      ユーザー認証トークンが無効な場合、前述の通りエンドユーザーは問題を提出できず、
      エラーが表示されます。独自のアラートを表示したり、サーバーから正しい認証トークンを
      再取得したい場合には、 このデリゲートを使用します。
    </td>
  </tr>
  <tr>
    <td>HelpshiftAuthenticationFailureReason.UNKNOWN</td>
    <td>認証失敗の理由が不明なとき</td>
  </tr>
</table>

認証失敗の理由は、列挙型`HelpshiftAuthenticationFailureReason`でラップされています。例:

```csharp
// ...
  public class HSEventsListener: IHelpshiftEventsListener
    {

        public void AuthenticationFailedForUser(HelpshiftAuthenticationFailureReason reason)
        {
            HelpshiftInternalLogger.d("Authentication Failed for reason " + reason.ToString());
        }

       // other methods
    }
// ...
// and register this event listener

using Helpshift;
// ..
//..
HelpshiftSdk _helpshiftX = HelpshiftSdk.GetInstance()
_helpshiftX.SetHelpshiftEventsListener(new HSEventsListener());
```
