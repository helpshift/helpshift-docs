---
sidebar_position: 85
title: アウトバウンドサポート
description: "アウトバウンドサポートを使用すれば、アプリ内で発生した問題を顧客と積極的に関わり合いながら解決へと導くことができます。この機能の詳細については、**[こちら](https://support.helpshift.com/hc/faq/1163-outbound-support-create-outbound-support-link)**をご参照ください。"
---

import {
  Admonition,
  CodeBlock,
  Tabs,
  TabItem,
  LatestSdkVersion,
  Centered,
  Image,
  Intro,
  SideBySide,
  DownloadButton,
  Steps,
  Step,
} from "@site/src/components/forDocs";

# アウトバウンドサポート {#outbound-support}

<Intro>

アウトバウンドサポートを使用すれば、アプリ内で発生した問題を顧客と積極的に関わり合いながら解決へと導くことができます。この機能の詳細については、**[こちら](https://support.helpshift.com/hc/faq/1163-outbound-support-create-outbound-support-link)**をご参照ください。

</Intro>

<Admonition type="info" title="注意">

SDKに含まれているすべてのパブリックAPIは、[Helpshift.install() API](/sdkx-unity/getting-started-ios#start-using)を介してSDKを初期化した後に呼び出す必要があります

</Admonition>

この機能の使用手順は、以下の通りです。

アウトバウンドサポート用のリンクを生成するには、Helpshiftのダッシュボードで、「**設定**」、「**ワークフロー**」、「**アウトバウンドのサポート**」の順に移動します。

![](/static/books/helpshiftx/outbound-support.png)

「**リンクを作成**」ボタンが表示されているはずです。「リンクを作成」ボタンをクリックし、**チャット、ヘルプセンター、シングルFAQ、FAQセクション**などのアクションと、Helpshift SDKにペイロードとして送信する**CIF、タグ、最初のユーザーメッセージ**などのデータを選択します。

<Image src="/static/books/helpshiftx/generate-link-box.png" width="full" />

最後に、URLエンコードされたペイロードのリンクを取得します。既存のプッシュ通知システムを使用して、このリンクを通知ペイロードに埋め込まれたエンドユーザーへと送信します。

YOUR_APP_IDENTIFIERには、アプリを識別する一意の文字列を指定できます。たとえば、myAppやmyAppSupportなど、アプリのディープリンクURLで使用するスキームのようなものを指定します。

<Image src="/static/books/helpshiftx/proactive-link.png" width="full" />

## プッシュ通知のデータをHelpshift SDKにデリゲートする {#delegate-notification-data}

アウトバウンドサポートのデータをHelpshiftに渡すには、以下の手順に従ってください。

1. アプリのプッシュ通知システムを使用して積極的なサポートを実施するユーザーにプッシュ通知を送信します

2. ユーザーが通知を介してアプリを開いたときに、通知データを`application:didReceiveRemoteNotification:`または`application:didReceiveRemoteNotification:fetchCompletionHandler:`の`handleProactiveLink:(NSString *) proactiveLink`関数を呼び出すことによってHelpshift SDKに渡すようにアプリ内でこの通知を処理します。

3. 提供されたリンクからデータを読み取り、アウトバウンドサポートダッシュボードから提供された構成を用いてHelpshiftのサポートを開きます。

```objc
[Helpshift handleProactiveLink:proactiveLink];
```

<Admonition type="danger" title="重要">

- アウトバウンドサポートとHelpshiftの両方の通知を管理する必要があります。例として、Helpshiftのチャットメッセージの通知を受信すると、`[Helpshift handleNotificationWithUserInfoDictionary:]`に続いて`completionHandler(UNNotificationPresentationOptionNone);`を呼び出すことができます。アウトバウンドサポートの通知を受信すると、`completionHandler(UNNotificationPresentationOptionAlert);`を実行することができます。

- これはあくまでも参考のための例です。実際の実装内容は、アプリの通知処理コードに依存します。

</Admonition>

たとえば、以下のコードは受信したプッシュ通知を処理し、それをデバイスの通知センターに表示する方法を示しています。

```objc
- (void) userNotificationCenter:(UNUserNotificationCenter *)center willPresentNotification(UNNotification *)notification withCompletionHandler:(void (^(UNNotificationPresentationOptions)) completionHandler {
    //Helpshift normal notification.
    if([[notification.request.content.userInfo objectForKey:@"origin"] isEqualToString:@"helpshift"]) {
        [Helpshift handleNotificationWithUserInfoDictionary:notification.request.content.userInfo isAppLaunch:NO];
        completionHandler(UNNotificationPresentationOptionNone);
    } else {
        // Display Outbound notification in app when app is in foreground.
        completionHandler(UNNotificationPresentationOptionAlert);
    }
}
```

### 通知の処理:

以下のコードでは、`Helpshift.handleProactiveLink()`を呼び出してプッシュ通知のデータをHelpshift SDKにデリゲートする方法を示しています。

```objc
- (void) userNotificationCenter:(UNUserNotificationCenter *)center
 didReceiveNotificationResponse:(UNNotificationResponse *)response
          withCompletionHandler:(void (^)(void))completionHandler {
    if([response.notification.request.content.userInfo[@"origin"] isEqualToString:@"helpshift"]) {
        [Helpshift handleNotificationWithUserInfoDictionary:response.notification.request.content.userInfo
                                                isAppLaunch:YES];
    } else {
        NSString* proactiveLink = response.notification.request.content.userInfo[@"helpshift_proactive_link"];
        if (proactiveLink != nil) {
            [Helpshift handleProactiveLink:proactiveLink];
        }
    }
    completionHandler();
}
```

## 現在のユーザーに固有の構成を渡す {#user-specific-config}

ユーザーが通知をクリックした際に、アプリ内の現在のユーザーに固有の構成を追加したい場合があるかもしれません。

ローカルAPIの構成を設定することにより、Helpshift SDKは（先のステップで述べたように）アウトバウンドサポートのリンクに埋め込まれた構成と、実行時に提供されるローカル構成の両方から構成をマージすることができます。このローカルAPIの構成は、`showConversation()`や`showFAQs()`のようなその他のAPIに期待される構成と全く同じです。

この構成は、現在の問題と、同じセッションで提出された次の問題に使用されます。

<Admonition type="info" title="注意">

このAPIは、[Helpshift Installation API](/sdkx-unity/getting-started-ios#initializing)よりも後、そして`Helpshift.handleProactiveLink()`よりも前に呼び出す必要があります。

</Admonition>

いずれかのクラスのパブリックインターフェース`IHelpshiftProactiveAPIConfigCollector`を実装し、`SetHelpshiftProactiveConfigCollector(new ProactiveConfigCollector())`メソッドを呼び出してHelpshift SDKのインストール呼び出しの後に構成コレクターデリゲートを初期化します。

`showConversation()`や`showFAQs()`のようなその他のパブリックAPIで追加する場合と同じフォーマットで、ユーザー固有の構成を追加するための`getLocalApiConfig()`メソッドを実装する必要があります。

この構成と、アウトバウンドサポートのリンクに埋め込まれている構成をマージします。**タグ、CIF**など、アウトバウンドサポートのリンクからの構成データをローカル構成に追加します。コンフリクトが発生した場合には、アウトバウンドサポートの構成が優先されます。

例:

```csharp
// initialise proactiveConfig collector

public class ProactiveConfigCollector : IHelpshiftProactiveAPIConfigCollector
{
    public Dictionary<string, object> getLocalApiConfig()
    {
        Dictionary<string, object> proactiveConfig = new Dictionary<string, object>();
        proactiveConfig.Add("initialUserMessage", "Hi there!");
        proactiveConfig.Add("fullPrivacy", true);
        proactiveConfig.Add("tags", new string[] { "vip", "payment", "blocked", "renewal" });
        ..
        ..
        return proactiveConfig;
    }
}
```
