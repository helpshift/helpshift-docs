---
sidebar_position: 85
title: アウトバウンドサポート
description: "アウトバウンドサポートを使用すれば、アプリ内で発生した問題を消費者と積極的に関わり合いながら解決へと導くことができます。この機能の詳細については、**[こちら](https://support.helpshift.com/hc/faq/1163-outbound-support-create-outbound-support-link)**をご参照ください。"
---

import {
  Admonition,
  CodeBlock,
  Tabs,
  TabItem,
  LatestSdkVersion,
  Centered,
  Image,
  Intro,
  SideBySide,
  DownloadButton,
  Steps,
  Step,
} from "@site/src/components/forDocs";

# アウトバウンドサポート {#outbound-support}

<Intro>

アウトバウンドサポートを使用すれば、アプリ内で発生した問題を消費者と積極的に関わり合いながら解決へと導くことができます。この機能の詳細については、**[こちら](https://support.helpshift.com/hc/faq/1163-outbound-support-create-outbound-support-link)**をご参照ください。

</Intro>

<Admonition type="info" title="注意">

SDKに含まれているすべてのパブリックAPIは、[Helpshift.install() API](/sdkx_ios/getting-started#start-using)を介してSDKを初期化した後に呼び出す必要があります

</Admonition>

この機能の使用手順は、以下の通りです。

アウトバウンドサポート用のリンクを生成するには、Helpshiftのダッシュボードで、「**設定**」、「**ワークフロー**」、「**アウトバウンドのサポート**」の順に移動します。

![](/static/books/helpshiftx/outbound-support.png)

「**新しいリンク**」ボタンが表示されているはずです。「新しいリンク」ボタンをクリックし、**チャット、ヘルプセンター、シングルFAQ、FAQセクション**などのアクションと、Helpshift SDKにペイロードとして送信する**CIF、タグ、最初のユーザーメッセージ**などのデータを選択します。

<Image src="/static/books/helpshiftx/generate-link-box.png" width="full" />{" "}

最後に、URLエンコードされたペイロードのリンクを取得します。既存のプッシュ通知システムを使用して、このリンクを通知ペイロードに埋め込まれたエンドユーザーへと送信します。

YOUR_APP_IDENTIFIERには、アプリを識別する一意の文字列を指定できます。たとえば、myAppやmyAppSupportなど、アプリのディープリンクURLで使用するスキームのようなものを指定します。

<Image src="/static/books/helpshiftx/proactive-link.png" width="full" />{" "}

## プッシュ通知のデータをHelpshift SDKにデリゲートする {#delegate-notification-data}

アウトバウンドサポートのデータをHelpshiftに渡すには、以下の手順に従ってください。

1. アプリのプッシュ通知システムを使用して積極的なサポートを実施するユーザーにプッシュ通知を送信します

2. ユーザーが通知を介してアプリを開いたときに、通知データを`application:didReceiveRemoteNotification:`または`application:didReceiveRemoteNotification:fetchCompletionHandler:`の`handleProactiveLink:(NSString *) proactiveLink`関数を呼び出すことによってHelpshift SDKに渡すようにアプリ内でこの通知を処理します。

3. 提供されたリンクからデータを読み取り、アウトバウンドサポートダッシュボードから提供された構成を用いてHelpshiftのサポートを開きます。

<Tabs groupId="ios-languages">

<TabItem value="Objective-C" label="Objective-C">

```objc
[Helpshift handleProactiveLink:proactiveLink];
```

</TabItem>
<TabItem value="Swift" label="Swift">

```swift
Helpshift.handleProactiveLink(proactiveLink)
```

</TabItem>

</Tabs>

<Admonition type="danger" title="重要">

- アウトバウンドサポートとHelpshiftの両方の通知を管理する必要があります。例として、Helpshiftのチャットメッセージの通知を受信すると、`[Helpshift handleNotificationWithUserInfoDictionary:]`に続いて`completionHandler(UNNotificationPresentationOptionNone);`を呼び出すことができます。アウトバウンドサポートの通知を受信すると、`completionHandler(UNNotificationPresentationOptionAlert);`を実行することができます。

- これはあくまでも参考のための例です。実際の実装内容は、アプリの通知処理コードに依存します。

</Admonition>

たとえば、以下のコードは受信したプッシュ通知を処理し、それをデバイスの通知バーに表示する方法を示しています。

<Tabs groupId="ios-languages">

<TabItem value="Objective-C" label="Objective-C">

```objc
- (void) userNotificationCenter:(UNUserNotificationCenter *)center
    willPresentNotification:(UNNotification *)notification
    withCompletionHandler:(void (^)(UNNotificationPresentationOptions))completionHandler {
    if([[notification.request.content.userInfo objectForKey:@"origin"] isEqualToString:@"helpshift"]) {
        // This is a notification from Helpshift push notification system
        [Helpshift handleNotificationWithUserInfoDictionary:notification.request.content.userInfo isAppLaunch:NO withController:self.window.rootViewController];
        completionHandler(UNNotificationPresentationOptionNone);
    } else {
        NSString* proactiveLink = [[notification.request.content.userInfo objectForKey:@"aps"] objectForKey:@"helpshift_proactive_link"];
        if (proactiveLink != nil) {
            // This is notification for handling Helpshift proactive link
            [Helpshift handleProactiveLink:proactiveLink];
            completionHandler(UNNotificationPresentationOptionNone);
        } else  {
            // This is not a notification from Helpshift system
            // This is your existing push notification system
            // Manage other normal notification here
            completionHandler(UNNotificationPresentationOptionAlert);
        }
    }
}
```

</TabItem>
<TabItem value="Swift" label="Swift">

```swift
func userNotificationCenter(_ center: UNUserNotificationCenter,
    willPresent notification: UNNotification,
    withCompletionHandler completionHandler: @escaping (UNNotificationPresentationOptions) -> Void) {
    if notification.request.content.userInfo["origin"] as? String == "helpshift" {
        // This is a notification from Helpshift push notification system
        Helpshift.handleNotification(withUserInfoDictionary: userInfo, isAppLaunch: false, with: rootViewController)
        completionHandler([])
    } else if let proactiveLink = notification.request.content.userInfo["aps"]["helpshift_proactive_link"] as? String {
        // This is notification for handling Helpshift proactive link
        Helpshift.handleProactiveLink(proactiveLink)
        completionHandler([])
    } else {
        // This is not a notification from Helpshift system
        // This is your existing push notification system
        // Manage other normal notification here
        completionHandler(.alert)
    }
}
```

</TabItem>

</Tabs>

## 現在のユーザーに固有の構成を渡す {#user-specific-config}

ユーザーが通知をクリックした際に、アプリ内の現在のユーザーに固有の構成を追加したい場合があるかもしれません。

ローカルAPIの構成を設定することにより、Helpshift SDKは（先のステップで述べたように）アウトバウンドサポートのリンクに埋め込まれた構成と、実行時に提供されるローカル構成の両方から構成をマージすることができます。このローカルAPIの構成は、`showConversation:`や`showFAQs:`のようなその他のAPIに期待される構成と全く同じです。

この構成は、現在の問題と、同じセッションで提出された次の問題に使用されます。

<Admonition type="info" title="注意">

このAPIは、[Helpshift Installation API](/sdkx_ios/getting-started#start-using)よりも後、そしてHelpshift.handleProactiveLink()よりも前に呼び出す必要があります。

</Admonition>

AppDelegateクラス内のパブリックインターフェース`HelpshiftProactiveAPIConfigCollectorDelegate`を実装し、`setProactiveAPIConfigCollectorDelegate:`メソッドを呼び出してHelpshift SDKのインストール呼び出しの後に構成コレクターデリゲートを初期化します。

`showConversation:`や`showFAQs:`のようなその他のパブリックAPIで追加する場合と同じフォーマットで、ユーザー固有の構成を追加するための`getAPIConfig`メソッドを実装する必要があります。

この構成と、アウトバウンドサポートのリンクに埋め込まれている構成をマージします。**タグ、CIF**など、アウトバウンドサポートのリンクからの構成データをローカル構成に追加します。コンフリクトが発生した場合には、アウトバウンドサポートの構成が優先されます。

例: 以下のコードは、`HelpshiftProactiveAPIConfigCollectorDelegate`を実装する方法と、`getAPIConfig`メソッドを使用してユーザー固有の構成を追加する方法を示しています。

<Tabs groupId="ios-languages">

<TabItem value="Objective-C" label="Objective-C">

```objc
// Set proactiveConfig collector delegate
[Helpshift.sharedInstance setProactiveAPIConfigCollectorDelegate:self];

// Delegate callback
- (nonnull NSDictionary *) getAPIConfig {
    NSDictionary *config = @{ @"tags":tagsArray,
                              @"cifs": cifDictionary };
    ..
    return localConfig;
}
```

<Admonition type="info" title="注意">
  <b>"customIssueFields"</b>{" "}
キーの使用が非推奨になることをお知らせします。カスタム問題フィールドを渡す方法として、{" "}
<b>"cifs"</b>キーの使用を強く推奨します。
</Admonition>

</TabItem>
<TabItem value="Swift" label="Swift">

```swift
// Set proactiveConfig collector delegate
Helpshift.sharedInstance.setProactiveAPIConfigCollectorDelegate(self)

// Delegate callback
func getAPIConfig() -> Dictionary<String, Any> {
    var config: [String: Any] = [
        "tags": tagsArray,
        "cifs": cifDictionary
    ]
    ...
    return config
}
```

<Admonition type="info" title="注意">
  <b>"customIssueFields"</b>{" "}
キーの使用が非推奨になることをお知らせします。カスタム問題フィールドを渡す方法として、{" "}
<b>"cifs"</b>キーの使用を強く推奨します。
</Admonition>

</TabItem>

</Tabs>
